
# Декораторы
### Объект пользователя и проверка аутентификации
В объекте запроса `request` хранится: URL и метод запроса, параметры запроса, содержимое заголовков header и много другое. Есть в нем и объект `user` - экземпляр модели пользователя, который отправил запрос. Если пользователь не аутентифицирован, то объект `user` также есть, но только с атрибутом `user.is_authenticated=False`. Именно с этим атрибутом можно настроить проверку разрешено ли пользователю зайти на определенную страницу. Например
```python
from django.shortcuts import redirect
...

def birthday_create(request):
    if not request.user.is_authenticated:
        # Если пользователь не залогинен — отправляем его на страницу для входа:
        return redirect('login')
    # Если пользователь авторизован — выполняем полезный код функции.
    ...
```
Такая проверка должна быть в каждой view-функции, в которой надо разграничить права, но тогда нарушается принцип DRY.
### Добавление функциональности, не изменяя код
Возникает ситуация, когда ко множеству функций необходимо добавить один и тот же код. В Python есть специальный инструмент, позволяющий добавлять к функциям определенные действия, не изменяя код.
**Декоратор** - паттерн проектирования, предназначенный для расширения функциональности объектов без вмешательства в код. Декоратор добавляет к функции заданные действия, ничего в ней не меняя.
### Фундамент декораторов
Для понимания декораторов необходимо помнить особенности Python:
1. Функции могут содержать в себе другие функции
```python
def outer_function():
    def inner_function(name):
        return f'Привет, {name}!'   
    result = inner_function('мир')
    return result


print(outer_function())

# Будет напечатано: Привет, мир!
```
	1. Вызвается `outer_fuction()`
	2. Она вызывает `inner_function()`
	3. Внутренняя функция возвращает строку и сохраняет в переменную result
	4. `outer_function()` возвращает result
2. Любая сущность в Python - объект
	Строки, числа, функции, классы - это все объекты
	```python
	print(type(42))
# Выведет:
# <class 'int'>
```
Функции принимают в качестве аргументов объекты, но так, как функция тоже является объектом, можно передать функцию аргументов в другую функцию.
### Замеряем время выполнения функции
```python 
import time


def sleep_one_sec():
    # Запоминаем время перед выполнением исходной функции.
    start_time = time.time()
    # Выполняем код исходной функции:
    time.sleep(1)
    # Вычисляем, округляем и печатаем разницу
    # между временем старта и актуальным временем.
    execution_time = round(time.time() - start_time, 1)
    print(f'Время выполнения функции: {execution_time} сек.')
    return 'Результат первой функции.'


def sleep_two_sec():
    start_time = time.time()
    # Теперь выполняем код исходной функции:
    time.sleep(2)
    execution_time = round(time.time() - start_time, 1)
    print(f'Время выполнения функции: {execution_time} сек.')
    return 'Результат второй функции.'
```
Код дублируется, редактировать нужно во многих местах. **Решение**: написать специальную функцию, которая будет принимать на вход другую функцию.

### Коробка с кнопкой
Функция - объект, который ждет, когда его вызовут. Такие объекты называются ==callable object==. 
Объект функции можно передать не вызывая
```python
# После имени функции sleep_one_sec нет скобок — это объект функции.
# Передаём объект функции аргументом в функцию print:
print(sleep_one_sec)

# Будет напечатано:
# <function sleep_one_sec at 0x0000028C2EDBC280>
```
А также можно передать результат вызова
```python
# После имени функции sleep_one_sec стоят скобки — это результат вызова функции.
# Передаём результат вызова функции аргументом в функцию print:
print(sleep_one_sec())

# Будет напечатано:
# Результат первой функции.
```
### Передаем функцию как аргумент в другую функцию
В разговоре о декораторах в аргументы передается именно объект функции, а не результат вызова
```python
# Функция time_of_function()
# принимает на вход тестируемую функцию
# и возвращает результат измерений:
def time_of_function(func):
    # Запоминаем время перед выполнением тестируемой функции.
    start_time = time.time()
    print('Время пошло.')
    # Вызываем тестируемую функцию.
    result = func()
    # Печатаем разницу между временем старта и актуальным временем.
    execution_time = round(time.time() - start_time, 1)
    print(f'Время выполнения функции: {execution_time} сек.')
    # Возвращаем результат выполнения тестируемой функции:
    return result

# Вызываем time_of_function(), 
# передаём в неё объект — функцию sleep_one_sec (без скобок):
print(time_of_function(sleep_one_sec))

# Будет напечатано:
# Время пошло.
# Время выполнения функции: 1.0 сек.
# Результат первой функции.
```
Теперь в `time_of_function()` можно передать любую функцию и в результате:
- исходная функция выполнит свои действия
- дополнительно вернется результат функции `time_of_function()`
Можно создать новую и вернуть новую функцию
```python
# Принимает на вход функцию:
def time_of_function(func):
    # Объявляем внутреннюю функцию — её-то и вернём, когда опишем.
    def wrapper():
        start_time = time.time()
        print('Время пошло')

        # Вызываем полученную функцию и 
        # cохраняем результат её выполнения в переменную.
        result = func()

        execution_time = round(time.time() - start_time, 1)
        # Можем использовать результат выполнения полученной функции:
        print(f'Через {execution_time} сек функция вернула «{result}»')
        # Возвращаем результат выполнения полученной функции.
        return result
    # Возвращаем функцию wrapper, но не вызываем её:
    return wrapper
```
>[!info] `time_of_function()` и есть декоратор, он изменяет поведение декорируемой функции. Сама же декорируемая функция при этом не модифицируется.

Декоратор, в который передан объект функции, вернет функцию, при этом она не будет вызвана
```python
# Вызываем декоратор, результат сохраняем в переменную.
result = time_of_function(sleep_one_sec)
# Печатаем полученное из декоратора значение:
print(result)
# Получим примерно такой вывод:
# <function time_of_function.<locals>.wrapper at 0x0000015FE5E74700>
# Это объект функции!
```
Чтобы получить результат выполнения декорированной функции - функцию, полученную из декоратора, нужно вызвать
```python
# Вызываем декоратор, результат сохраняем в переменную.
result = time_of_function(sleep_one_sec)

# Переменная result — это функция; значит, её можно вызвать.
# Вызовем и напечатаем результат её выполнения:
print(result())
# Будет напечатано:
# Время пошло
# Через 1.0 сек. функция вернула «Результат первой функции»
# Результат первой функции
```
Можно вызывать декорированную функцию, через декоратор
```python
# Исходная функция.
sleep_one_sec

# Вызов исходной функции.
sleep_one_sec()

# Декорированная исходная функция.
time_of_function(sleep_one_sec)

# Вызов декорированной исходной функции.
time_of_function(sleep_one_sec)()

# Распечатка вызова декорированной функции.
print(time_of_function(sleep_one_sec)())
```
### Декоратор Python
Структура декоратор
```python
def the_decorator(func):
    # Вложенная функция.
    def wrapper():        
        ...
        result = func()
        ...
        return result
    # Декоратор возвращает вложенную функцию.
    return wrapper
```
Вместо вызова через скобки используется упрощенный синтаксис - синтаксический сахар. Перед объявлением этой функции ставится название функции-декоратора, а перед названием `@`.
```python
@time_of_function  # Декорируем!
def sleep_one_sec():
    time.sleep(1)
    return 'Результат первой функции'
```
Теперь при вызове задекорированной функции Python вызовет декоратор и передаст вызванную функцию в декоратор.
```python
@time_of_function
def sleep_one_sec():
    time.sleep(1)
    return 'Результат первой функции'

sleep_one_sec() 
# При вызове задекорированной функции sleep_one_sec() 
# Python подменит этот вызов на вызов декоратора и выполнит вернувшуюся функцию.

# Где-то под капотом вместо sleep_one_sec()
# будет выполнен такой вызов: time_of_function(sleep_one_sec)()
```
Условия, чтобы синтаксис сработал:
- в декораторе должна быть вложенная функция
- декоратор должен возвращать функцию
- декоратор должен быть объявлен до декорируемой функции
```python
import time

# Декоратор объявляется до декорируемой функции.
def time_of_function(func):
    # В декораторе должна быть вложенная функция.
    def wrapper():  
        start_time = time.time()
        print('Время пошло')
        result = func()
        execution_time = round(time.time() - start_time, 1)
        print(f'Через {execution_time} сек. функция вернула «{result}»')
        return result 
    # Нельзя вернуть строку, число или другой "невызываемый" объект.      
    return wrapper 


# Имя функции-декоратора (с символом @) 
# ставится перед объявлением декорируемой функции.
@time_of_function
def sleep_one_sec():
    time.sleep(1)
    return 'Результат первой функции'


# После декорирования любой вызов функции sleep_one_sec() 
# будет автоматически сопровождаться измерением времени её выполнения.
sleep_one_sec()

# Будет напечатано: 
# Время пошло
# Через 1.0 сек. функция вернула «Результат первой функции»

```
На одну функцию можно навесить множество декораторов, каждый из которых добавит свои действия.

### Декораторы для разграничения прав доступа
В Django есть встроенные декораторы, с помощью которых ко view-функциям можно добавить проверку залогинен пользователь или нет. Если да, то функция выполнится, если нет, то пользователь будет отправлен на страницу логина.
```python
from django.contrib.auth.decorators import login_required


# Встроенный в Django декоратор @login_required проверит пользователя
# и вернёт страницу только залогиненному пользователю.
# А незалогиненный будет отправлен на страницу логина.

@login_required  # Как можно не любить сахар!
def birthday_create(request):
    # Полезный код функции.
    ...
```
## Разграничение доступа
В Django есть встроенные декораторы, предназначенные для решения самых востребованных задач. Доступ к определенным страницам ограничивается на уровне представлений (views). Если страница управляется с помощью view-функции, то перед объявлением добавляется встроенный декоратор (`@login_required`). Если страница генерируется с CBV, то к классу добавляется миксин (`LoginRequiredMixin`). При проверке, если пользователь анонимный, представление переадресует на стандартную страницу логина (`LOGIN_URL`). Если пользователь аутентифицированный, то вернёт запрошенную страницу.
### Декоратор `@login_required`
Используется, чтобы предоставить доступ только залогиненным пользователям. Импортируется из `django.contrib.auth.decorators`.
```python
# birthday/views.py
...
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse


@login_required
def simple_view(request):
    return HttpResponse('Страница для залогиненных пользователей!')

...
```
```python
# birthday/urls.py
...
urlpatterns = [
    ...
    path('login_only/', views.simple_view),
    ...
]
```
### Проверка аутентификации для CBV
Можно добавить функцию-декоратор в *urlpatterns*.
```python
from django.contrib.auth.decorators import login_required

urlpatterns = [
    ...
    # Декорируем вызов метода as_view(), без синтаксического сахара:
    path('create/', login_required(views.BirthdayCreateView.as_view()), name='create'),
    ...
]
```
Но этот способ не особо распространен. Применяют [миксин LoginRequiredMixin](https://docs.djangoproject.com/en/3.2/topics/auth/default/#the-loginrequired-mixin).
```python
from django.contrib.auth.mixins import LoginRequiredMixin


class BirthdayCreateView(LoginRequiredMixin, CreateView):
    model = Birthday
    form_class = BirthdayForm
```
При этом в маршрут никаких изменений вносить не нужно.
### Работа с формами и пользователями
Также необходимо настроить права для редактирования и удаления объектов. Для этого каждый объект модели должен быть связан с определенным объектом модели пользователя. 
```python
# birthday/models.py
from django.contrib.auth import get_user_model

# Да, именно так всегда и ссылаемся на модель пользователя!
User = get_user_model()


class Birthday(models.Model):
    ...
    author = models.ForeignKey(
        User, verbose_name='Автор записи', on_delete=models.CASCADE, null=True
    )
```
`null=True` позволит не указывать значения по умолчанию для уже созданных объектов. После этого создать и выполнить миграции. В настройках формы необходимо заменить атрибут `fields=__all__` и исключить показ атрибута связанного с пользователем в форме.
```python
class BirthdayForm(forms.ModelForm):

    class Meta:
        model = Birthday
        exclude = ('author',)
        ...
```
Объект пользователя можно получить из запроса, из свойства `request.user`. [Документация](https://docs.djangoproject.com/en/3.2/topics/class-based-views/generic-editing/#models-and-request-user) сообщает, что присвоить значение нужному полю в CBV можно через переопределение метода валидации:
```python
class BirthdayCreateView(LoginRequiredMixin, CreateView):
    model = Birthday
    form_class = BirthdayForm

    def form_valid(self, form):
        # Присвоить полю author объект пользователя из запроса.
        form.instance.author = self.request.user
        # Продолжить валидацию, описанную в форме.
        return super().form_valid(form)
```
Если в проекте применяются view-функции то:
1. При обработке формы создается объект модели, но не сохраняется в БД. Выполняется с помощью метода `form.save()` с аргументов `commit=False`
```python
 def birthday(request):
     form = BirthdayForm(request.POST or None)
     context = {'form': form}
     if form.is_valid():
         instance = form.save(commit=False)
 
```
2. После этого полю объекта присваивается нужное значение 
```python
 ...
     if form.is_valid():
         instance = form.save(commit=False)
         instance.author = request.user
 ...
 
```
3. Затем сохранить объект модели в БД. 
```python
 ...
     if form.is_valid():
         instance = form.save(commit=False)
         instance.author = request.user
         instance.save()
 ...
 
```
Пользователь привязан к объекту модели, можно проверять авторство объекта
### Проверка авторства объекта
Доступ к страницам редактирования и удаления должен быть только у объекта модели пользователя. Можно вернуть ошибку 403, а можно переадресовать на другую страницу. А можно вернуть ошибку 404, чтобы пользователь не думал, что страница существует.
При работе с view-функцией объект модели обычно получают с помощью `get_object_or_404()`. Для проверки авторизации добавляется дополнительный фильтр
```python
def edit_birthday(request, pk):
    # При поиске объекта дополнительно указываем текущего пользователя.
    instance = get_object_or_404(Birthday, pk=pk, author=request.user)
```
При работе с CBV нужно переопределить [метод](https://docs.djangoproject.com/en/3.2/ref/class-based-views/base/#django.views.generic.base.View.dispatch) `dispatch()`, который как проводник перенаправляет запросы согласно запросам: GET-запрос к методу CBV `get()`, POST-запрос к методу `post()`, и так далее. 
```python
class BirthdayUpdateView(LoginRequiredMixin, UpdateView):
    model = Birthday
    form_class = BirthdayForm

    def dispatch(self, request, *args, **kwargs):
        # Получаем объект по первичному ключу и автору или вызываем 404 ошибку.
        get_object_or_404(Birthday, pk=kwargs['pk'], author=request.user)
        # Если объект был найден, то вызываем родительский метод, 
        # чтобы работа CBV продолжилась.
        return super().dispatch(request, *args, **kwargs)
```
Если вместо ошибки 404, необходимо показать ошибку 403 или перенаправить на другую страницу, то
```python
# Импортируем 403 ошибку:
from django.http import HttpResponseForbidden


class BirthdayUpdateView(LoginRequiredMixin, UpdateView):
    model = Birthday
    form_class = BirthdayForm

    def dispatch(self, request, *args, **kwargs):
        # При получении объекта не указываем автора.
        # Результат сохраняем в переменную.
        instance = get_object_or_404(Birthday, pk=kwargs['pk'])
        # Сверяем автора объекта и пользователя из запроса.
        if instance.author != request.user:
            # Здесь может быть как вызов ошибки, так и редирект на нужную страницу.
            raise HttpResponseForbidden
        return super().dispatch(request, *args, **kwargs)
```
Такую проверку можно выполнять и во view-функции. 
### Разграничение прав в шаблоне
Необходимо скрыть ссылки ото всех, кроме автора записи.
В шаблоне доступен объект пользователя `user` и объект модели. Ссылки на редактирование и удаление необходимо показывать только в случае, если `user==<объект_модели>`
```html
{% if birthday.author == user %}
  <div>
    <a href="{% url 'birthday:edit' birthday.id %}">Изменить запись</a> | <a href="{% url 'birthday:delete' birthday.id %}">Удалить запись</a>
  </div>
{% endif %}
```
